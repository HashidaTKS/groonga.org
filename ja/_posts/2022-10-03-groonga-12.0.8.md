---
layout: post.ja
title: Groonga 12.0.8リリース
description: Groonga 12.0.8をリリースしました！
---

## Groonga 12.0.8リリース

[Groonga 12.0.8](/ja/docs/news.html#release-12-0-8)をリリースしました！

それぞれの環境毎のインストール方法: [インストール](/ja/docs/install.html)

### 変更内容

主な変更点は以下の通りです。

### 改良

* 新しい関数 `escalate()` を追加しました。

  `escalate()` の仕様を以下の通り変更しました。

  * しきい値の比較に `escalate()` の内部の結果セットのみを使うように変更しました。

    `escalate()` の外部の結果セットは使用しません。

  * 最初の条件のためのしきい値は不要となりました。（例: `escalate(CONDITION1, THRESHOLD2, CONDITION2, ...)` ）
  * 引数の指定を必須としました。最初の条件が必須となります。
  * 最初の条件を常に実行します。

* [cmake](/ja/docs/install/cmake.html) CMakeを使ってビルドする方法を追加しました。

* [others](/ja/docs/install/others.html) GNU Autotoolsを使ってビルドする場合に、Apache Arrowの機能を有効化/無効化する方法について追加しました。

* [select](/ja/docs/reference/commands/select.html) `drilldowns.table` のドキュメントを追加しました。

* [i18n](/ja/docs/contribution/documentation/i18n.html) 翻訳方法を更新しました。

### 改良

* [NormalizerTable](/ja/docs/reference/normalizers/normalizer_table.html) で冪等でない（繰り返し実行すると結果が変わることがある）定義をした時に、Groongaが誤った結果を返すことがある問題を修正しました。

  これは、検索する値について、値を受け取った後と、トークナイズした後の二回ノーマライズしていたことが原因です。

  以下はこのバグの例です。

  ```
  table_create ColumnNormalizations TABLE_NO_KEY
  column_create ColumnNormalizations target_column COLUMN_SCALAR ShortText
  column_create ColumnNormalizations normalized COLUMN_SCALAR ShortText

  load --table ColumnNormalizations
  [
  {"target_column": "a", "normalized": "b"},
  {"target_column": "b", "normalized": "c"}
  ]

  table_create Targets TABLE_PAT_KEY ShortText
  column_create Targets column_normalizations_target_column COLUMN_INDEX \
    ColumnNormalizations target_column

  table_create Memos TABLE_NO_KEY
  column_create Memos content COLUMN_SCALAR ShortText

  load --table Memos
  [
  {"content":"a"},
  {"content":"c"},
  ]

  table_create \
    Terms \
    TABLE_PAT_KEY \
    ShortText \
    --default_tokenizer 'TokenNgram("unify_alphabet", false, \
                                    "report_source_location", true)' \
    --normalizers 'NormalizerTable("normalized", \
                                  "ColumnNormalizations.normalized", \
                                  "target", \
                                  "target_column")'

  column_create Terms memos_content COLUMN_INDEX|WITH_POSITION Memos content

  select Memos --query content:@a
  [[0,1664781132.892326,0.03527212142944336],[[[1],[["_id","UInt32"],["content","ShortText"]],[2,"c"]]]]
  ```

  `select Memos --query content:@a` の結果の期待値は `a` ですが、Groongaは `c` を返していました。
  これは、入力された `a` が `ColumnNormalizations` の定義にしたがって `b` にノーマライズされ、
  その後、 ノーマライズされた `b` を更に `c` にノーマライズしていたためです。
  結果的に、入力された `a` は `c` に変換され、 `Memos` テーブルの `{"content":"c"}` にマッチしていました。

### 既知の問題

* 現在Groongaには、ベクターカラムに対してデータを大量に追加、削除、更新した際にデータが破損することがある問題があります。

* ``*<`` と ``*>`` は、filter条件の右辺に ``query()`` を使う時のみ有効です。もし、以下のように指定した場合、 ``*<`` と ``*>`` は ``&&`` として機能します。

  ```
  'content @ "Groonga" *< content @ "Mroonga"'
  ```

* ``GRN_II_CURSOR_SET_MIN_ENABLE`` が原因でマッチするはずのレコードを返さないことがあります。

### さいごに

詳細については、以下のお知らせも参照してください。

[お知らせ 12.0.8リリース](/ja/docs/news.html#release-12-0-8)

それでは、Groongaでガンガン検索してください！
